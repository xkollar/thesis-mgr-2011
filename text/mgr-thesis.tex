% vim: spell
\documentclass[11pt,oneside,draft]{fithesis2}

\usepackage[draft]{pgf}
%\usepackage[slovak]{babel}
\usepackage[english]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[plainpages=false,pdfpagelabels,unicode]{hyperref}
\usepackage{lmodern}

\usepackage{amsmath,amsthm,amsfonts}
%\usepackage{ae}
\usepackage{fancyvrb}
\usepackage{enumerate}
\clubpenalty=1000
\widowpenalty=1000
\renewcommand{\baselinestretch}{1.08}

\newcommand{\kindStar}{\star}

\DefineVerbatimEnvironment{code}{Verbatim}
        { fontsize=\small
        , commentchar=@
        , frame=single
        %, numbers=left
        %, framesep=5pt
        %, fontshape=sl
        , commandchars=\\\{\}
        , framesep=5pt
        %, fontshape=sl
        }

\newtheorem{lemma}{Lemma}
\newtheorem{example}{Example}

%\thesistitle{Rozšírenia typového systému pre Haskell}
\thesistitle{Extensions of Haskell type system}
%\thesissubtitle{Diplomová práca}
%\thesissubtitle{Master Thesis}
\thesissubtitle{Diploma Thesis}
\thesisstudent{Matej Kollár}
\thesiswoman{false}
\thesisfaculty{fi}
%\thesisyear{jar 2011}
\thesisyear{autumn 2011}
\thesisadvisor{Libor Škarvada, RNDr.}
%\thesislang{sk}
\thesislang{en}

\begin{document}
\FrontMatter
\ThesisTitlePage

\begin{ThesisDeclaration}
\DeclarationText
\AdvisorName
\end{ThesisDeclaration}

\begin{ThesisThanks}
I would like to thank to Libor, Zuzana and Mom.
\end{ThesisThanks}

\begin{ThesisAbstract}
The aim of the master's thesis/work is to provide...
\end{ThesisAbstract}

% XXX! Check whether they are relevant.
\begin{ThesisKeyWords}
Haskell, type system, type extension
\end{ThesisKeyWords}

\tableofcontents

\MainMatter

\chapter{Introduction}

\chapter{Type system}

(Part of introduction?)\dots

\section{Haskell type system}

Before discussing extensions it would be desirable to describe
original type system itself.
As one can find not only in \cite{haskell2010}, Haskell uses a traditional
Hindley-Milner polymorphic type system to provide a static type
semantics enriched with type classes that provide structural way to
introduce overloaded functions.

\begin{example}~
\[ \texttt{id} :: \forall a \in {\kindStar} \, . \, a \]
\[ \texttt{const} :: \forall a \in {\kindStar} \, . \, \forall b \in {\kindStar} \, . \, a \to b \to a \]
\end{example}

\begin{example}~
\[ \texttt{1} :: \forall a \in \texttt {Num} \, . \, a \]
\[ \texttt{elem} :: \forall a \in \texttt{Eq} \, . \, a \to [a] \to \texttt{Bool} \]
\end{example}

\begin{example}~
\begin{code}
ex :: (C1 a,C2 a) => a
\end{code}
\[ \texttt{ex} :: \forall \, a \in \texttt{C1} \cap \texttt{C2} \, . \, a \]
\end{example}

\begin{example}
This one is ugly and points out some problems.
\begin{code}
ex :: (Eq (m a), Monad m) => m a -> a -> Bool
ex x y = x == return y
\end{code}
There are few possibilities how to deal with this. For example
\[ \texttt{ex} :: \forall m \in \texttt{Monad} \cap \emptyset \to \texttt{Eq} \, . \, \forall m \, a \in \texttt{Eq} \, . \, m \, a \to a \to \texttt{Bool} \]
but this would require to make possible quantification not only over variables but over applications too.
We will rather stick with following alternative:
\[ \texttt{ex} :: \forall a \in \kindStar \, . \, forall m \in \texttt{Monad} \cap \{ a \} \to \texttt{Eq} \, . \, m \, a \to a \to \texttt{Bool} \]
Both of this possibilities embodies some ``dependency'', that gives significance to order of quantifications.
We will show how to deal with this later. % XXX : later... multiparam type classes.
\end{example}

\begin{example}~
\begin{code}
ex :: (Monad m, Eq (m a), Eq a) => m a -> a -> Bool
ex x y = y == y && x == return y
\end{code}
\[ \texttt{ex} :: \forall m \in \texttt{Monad} \cap \texttt{Eq} \to \texttt{Eq} \, . \, \forall a \in \texttt{Eq} \, . \, m a \to a \to \texttt{Bool} \]
\end{example}

This leads to situation, where one th

Contexts, context reductions... blah blah... much better solution -- watch this:
\begin{align*}
	\tau   & ::= \forall \, a \in \kappa \, . \, \tau ~|~ \sigma \\
	\sigma & ::= a ~|~ \sigma \to \sigma ~|~ \rho \, \sigma \\
	\rho   & ::= a ~|~ \rho \, \sigma \\
	\kappa & ::= c ~|~ \kindStar ~|~ \kappa \to \kappa ~|~ \kappa \cap \kappa \\
\end{align*}
where
\begin{itemize}
	\item \(a\) stands for type variable,
	\item \(c\) stands for kind constant,
	\item \(\tau\) represents types,
	\item and \(\kappa\) represents types kinds.
\end{itemize}

Key in understanding this fact (noticed by \cite{libor}),
that as classes are sets of type constructors, they are kinds.
Not only that, they form obvious structure -- half lattice with operation
\(\cap\).

Type class declaration creates new kind constant.
Instances fill selected classes (constants explicitly, others implicitly).
Analogously \texttt{data} creates and fills types.

% XXX: Is it really sort that matters?
Intersection have sense (understand possibility of not-emptiness) only on
kinds with same sort(?) (\(\texttt{Eq} \cap \texttt{Functor}\) even feels wrong).

Inclusion diagrams accompanying some distinguished type classes can be found for
example in \cite{typeclassopedia}.

% XXX: Eventually remove this text and if possible replace
%      with 15 pages of text ;-).
This was expected to generate like 15 pages in thesis \verb~:-/~.

\section{Removing type-class infrastructure}

As noticed by many and underlined by actual implementation, type-classes can be removed
from language with only little ``harm''.

Let us have a look at how it can be done. Take following well known example.
\begin{code}
class Eq a where
    (==), (/=) :: a -> a -> Bool
\end{code}
And definitions that employ this class.
\begin{code}
(==) :: Eq a => a -> a -> Bool
elem :: Eq a => a -> [a] -> Bool
elem = any . (==)
f :: Eq a => a -> [[a]] -> Bool
f = any . elem
\end{code}
This can be expressed in following way:
\begin{code}
type Eq a = (a -> a -> Bool,a -> a -> Bool)
\end{code}
with definitions
\begin{code}
(==) :: Eq a -> a -> a -> Bool
(==) = fst

elem :: Eq a -> a -> [a] -> Bool
-- elem ((==),(/=)) = any . (==)
-- or
elem i = any . (==) i

f :: Eq a -> a -> [[a]] -> Bool
f i = any . elem i
\end{code}

One may naturally wonder, how it would be with non-\(\kindStar\) classes.
Take \texttt{Monad}.
\begin{code}
class Monad m where
	return :: a -> m a
	(>>=) :: m a -> (a -> m b) -> m b
\end{code}
(Function \texttt{fail} is omitted intentionally but can be added with
no problem as curious reader try as simple exercise.)
Most straightforward way how to express it would be
\begin{code}
type Monad m a b = (a -> m a,m a -> (a -> m b) -> m b)
\end{code}
But what have we done? This is not traditional \texttt{Monad} but
multi-parameter. This is another example for multi-parameter type classes
being natural. But how to do it intended way?
\begin{code}
type Monad m = forall a b . (a -> m a,m a -> (a -> m b) -> m b)
\end{code}


\chapter{Extensions}

This chapters goes trough various type extensions showing examples
what can be achieved using them with focus on what they have in common
and where they differ.

\section{Empty data declarations}

% This extension is implemented in \texttt{GHC} and can be enabled via
% \texttt{LANGUAGE} pragma \texttt{EmptyDataDecls}.
This extension was included in standard in Haskell 2010.

Extension \emph{empty data declarations} allows empty data declarations
(without any data constructors). This is very natural as there is possible
to declare types with arbitrary number of constructors (except 0). In
fact, it is not extension in sense of adding something artificial in
language, it only make syntax more comprehensive. Using this extension can
be empty (except \(\bot\)) data type \texttt{Empty} declared in this way:
\begin{code}
data Empty
\end{code}
However, the same can be achieved without this extension as well. Consider type \texttt{Empty'}
declared with \texttt{newtype}.
\begin{code}
newtype Empty' = E' Empty'
\end{code}
It looks like there actually are values besides \(\bot\), namely \(\texttt{E'}^n \, \bot\)
for every \(n \in \mathbb{N}_0\) and \(\mu x . \texttt{E'} \, x\).
Those are, as shown in lemma \ref{emptyTypes}, indistinguishable from \(\bot\).

\begin{lemma}[Empty types]
\label{emptyTypes}
If there is value \(v :: \texttt{Empty'}\), then \(v \approx \bot\).
\end{lemma}

\begin{proof}
In \cite{haskell2010} is stated, that \(\texttt{Empty'} \, \bot \approx \bot\).
Simple induction provides us all \(\texttt{E'}^n \, \bot\) cases
and least fixed point case is obvious as well, as \(\bot\) is least element.
\end{proof}

This ``extension'' is in fact very natural. Definition of \texttt{Empty'}
might give user feeling that it is non-empty, whereas emptiness is
obvious in case of \texttt{Empty}.

Analogous construction can be done with type constructors.

When defining empty type without this extension be sure to use
\texttt{newtype}, not \texttt{data}, as it will be inhabited not only with \(\bot\).
\begin{code}
data EmptyBad = EB EmptyBad
\end{code}

\begin{lemma}
There exists value \(v :: \texttt{EmptyBad}\) such that \(v \not \approx \bot\).
\end{lemma}

\begin{proof}
Let \texttt{emptyBad} be catamorphism over \texttt{EmptyBad}.
\begin{code}
emptyBad :: (a -> a) -> EmptyBad -> a
emptyBad f (EB x) = f (emptyBad x)
\end{code}
Now consider \(\texttt{emptyBad fac (fix EB)}\) and \(\texttt{emptyBad fac} \, \bot\).
They are obviously distinguishable as first one is factorial function but second one is \(\bot\) itself.
\end{proof}

\section{Multi-parameter type classes}

This extension is implemented in \texttt{GHC} and can be enabled via
\texttt{LANGUAGE} pragma \texttt{MultiParamTypeClasses}.

\subsection{Functional dependencies}

\subsection{Relaxed rules for instances}

\subsubsection{Relaxed rules for the instance head}

\texttt{TypeSynonymInstances} Not much interesting.

\subsubsection{Relaxed rules for instance contexts}

\begin{itemize}
\item \texttt{FlexibleContexts}
\item \texttt{UndecidableInstances}
\item \texttt{OverlappingInstances} \texttt{IncoherentInstances}
\end{itemize}

\subsection{Examples}

Subtyping.

\section{Generalised algebraic datatypes}

\section{Extensible kinds}

\section{Rank-2 types}

\subsection{Rank-n types}

% \section{Subtyping} % as example

\chapter{Examples}

\section{Apples and oranges}

Problem is simple: we do not want do jumble apple and oranges,
exactly like we were taught in elementary school.

\subsection{Phantom types \& Empty data declarations}

This solution is simple and clean.
\begin{code}
data Apple
data Orange

newtype Count a = Count Integer

plus :: Count a -> Count a -> Count a
Count x `plus` Count y = Count (x + y)
\end{code}
Most interesting thing here is function \texttt{plus}, that itself has more general type, but
by narrowing it down to more specific one we get function that allows us
adding up oranges with oranges, apples with apples, but forbids any other combinations
of apples and oranges. Advantage of this solution is that it is polymorphic
and we do not need to separately write code for apples and oranges.

On the contrary, this can be also seen as drawback, as one can create value
of type \texttt{Count Bool} which we have not intended. However,
one can take this in count by writing:
\begin{code}
data Apple
data Orange

class Fruit a where

instance Fruit Apple
instance Fruit Orange

newtype Count a = Count Integer

plus :: Fruit a => Count a -> Count a -> Count a
Count x `plus` Count y = Count (x + y)
\end{code}

As every elementary school child notices, from time to time one need to add apples and oranges,
and result will not be such nonsense:
\begin{code}
data Fruit'
instance Fruit Fruit'

plus' :: Fruit a => Count a -> Count b -> Count Fruit'
Count x `plus'` Count y = Count (x + y)
\end{code}

\chapter{Unified view}

% \chapter{Own extension proposal}

%\chapter{Z\'aver}
\chapter{Conclusion}

I came to conclusion that violet cows are present mainly in ads.

\bibliographystyle{apalike}
\bibliography{bibliography}

\end{document}
