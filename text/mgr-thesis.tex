% vim: spell
\documentclass[11pt,oneside,draft]{fithesis2}

%\usepackage[draft]{pgf}
\usepackage{tikz}

%\usepackage[slovak]{babel}
\usepackage[english]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[plainpages=false,pdfpagelabels,unicode]{hyperref}
\usepackage[all]{hypcap}
\usepackage{caption}
\usepackage{chemarrow}

\usepackage{amsmath,amsthm,amsfonts}
\usepackage{lmodern}
\usepackage{mathrsfs}
%\usepackage{ae}

\usepackage{fancyvrb}
\usepackage{enumerate}
\clubpenalty=1000
\widowpenalty=1000
\renewcommand{\baselinestretch}{1.08}

\newcommand\uv[1]{``#1''}
\renewcommand{\to}{\mathop{\chemarrow}}
%\let\to\chemarrow

%% Symbols used in generated graphics
%\newcommand{\kindStar}{\star}
\input{someprelude}

\DefineVerbatimEnvironment{code}{Verbatim}
        { fontsize=\small
        , commentchar=@
        , frame=single
        %, numbers=left
        %, framesep=5pt
        %, fontshape=sl
        , commandchars=\\\{\}
        , framesep=5pt
        %, fontshape=sl
        }

\newtheorem{lemma}{Lemma}

\theoremstyle{definition}
\newtheorem{example}{Example}

%\thesistitle{Rozšírenia typového systému pre Haskell}
\thesistitle{Extensions of Haskell type system}
%\thesissubtitle{Diplomová práca}
%\thesissubtitle{Master Thesis}
\thesissubtitle{Diploma Thesis}
\thesisstudent{Matej Kollár}
\thesiswoman{false}
\thesisfaculty{fi}
%\thesisyear{jar 2011}
\thesisyear{autumn 2011}
\thesisadvisor{Libor Škarvada, RNDr.}
%\thesislang{sk}
\thesislang{en}

\begin{document}
\FrontMatter
\ThesisTitlePage

\begin{ThesisDeclaration}
\DeclarationText
\AdvisorName
\end{ThesisDeclaration}

\begin{ThesisThanks}
I would like to thank to Libor, Zuzana and mommy.
\end{ThesisThanks}

\begin{ThesisAbstract}
The aim of the master's thesis/work is to provide...
\end{ThesisAbstract}

% XXX! Check whether they are relevant.
\begin{ThesisKeyWords}
Haskell, type system, type extension
\end{ThesisKeyWords}

\tableofcontents
\listoffigures

\MainMatter

\chapter{Introduction}

\chapter{Type system}

% \begin{align*}
% 	\mathscr{A} & \to \mathscr{BCDEFGHIJKLMNOPQRSTUVWXYZ} \\
% 	\mathcal{A} & \to \mathcal{BCDEFGHIJKLMNOPQRSTUVWXYZ}
% \end{align*}

% XXX: Move this to introduction?
Talking about extensions of type system requires understanding what type system is.
In this work we will understand type system (similarly as
\cite{pierce:2002:types,barendregt:1992:lambdaProc}) a formal system providing

\begin{description}
	\item[safety] -- meaningless or invalid code can be detected at compile time,
	\item[optimization] -- useful information might be obtained as a by-product of static type-checking,
	\item[documentation] -- types provide information on how various parts can be combined together,
	\item[abstraction] -- types provide higher level of thinking about programs,
	\item[specification] -- specifying type narrows possibilities how to write down programs,
		eliminating many erroneous possibilities.
\end{description}

These qualities are typically achieved by meta system, typically
enriching syntax of a language and set of rules that restrict how can
simpler programs combined into more complex ones.
Check for these rules is done statically (at compile time).
%Static typing, Strong typing, \dots

\section{Haskell type system}

% It is desirable that we give description of the original type system before
% discussing its extensions.
Before discussing extensions it would be desirable to give description
of the original type system.
As we can find not only in \cite{haskell2010}, Haskell uses a traditional
Hindley-Milner polymorphic type system to provide a static type
semantics enriched with type classes that provide structural way to
introduce overloaded functions.

Types and terms are two different things, types are polymorphic,
type variables are implicitly universally quantified at the top level of type.
Type system provides not only type checking but also type inference.

Basic/Constant types
\begin{code}
()   :: ()
True :: Bool
'a'  :: Char
1    :: Integer
\end{code}

Type Constructors
\begin{code}
[1, 2, 3]        :: [Integer]
(True, 'a')      :: (Bool, Char)
Just [((), "a")] :: Maybe [((), String)]
isAlpha          :: Char -> Bool
\end{code}

Polymorphic types
\begin{code}
id    :: a -> a
const :: a -> b -> a
\end{code}

What do these types mean? Type of identity function tells us, that
it can take as argument value of any type and it returns value of the
same type. Well, not exactly any type. We are interested in inhabited
types only. But we know category that consists only of these types~--
kind \(\kindStar\). Let us write that in explicit way.

%\begin{example}~
\begin{align*}
\texttt{id} & :: \forall a \in {\kindStar} \, . \, a \to a \\
\texttt{const} & :: \forall a \in {\kindStar} \, . \, \forall b \in {\kindStar} \, . \, a \to b \to a \\
\end{align*}
% \[ \texttt{id} :: \forall a \in {\kindStar} \, . \, a \to a \]
% \[ \texttt{const} :: \forall a \in {\kindStar} \, . \, \forall b \in {\kindStar} \, . \, a \to b \to a \]
%\end{example}

Somewhere between concrete and polymorphic lies values with polymorphic overloading.
\begin{code}
1    :: Num a => a
elem :: Eq a => a -> [a] -> Bool
sum  :: Num a => [a] -> a
\end{code}
What does this types mean? There clearly is some sort of quantification, but not over all
possible \(\kindStar\) types. Those classes are therefore somehow subkinds of \(\kindStar\).
Again, let us make this notion more explicit.

%\begin{example}~
\begin{align*}
\texttt{1} & :: \forall a \in \texttt {Num} \, . \, a \\
\texttt{elem} & :: \forall a \in \texttt{Eq} \, . \, a \to [a] \to \texttt{Bool} \\
\texttt{sum} & :: \forall a \in \texttt{Num} \, . \, [a] \to a \\
% \[ \texttt{1} :: \forall a \in \texttt {Num} \, . \, a \]
% \[ \texttt{elem} :: \forall a \in \texttt{Eq} \, . \, a \to [a] \to \texttt{Bool} \]
% \[ \texttt{sum} :: \forall a \in \texttt{Num} \, . \, [a] \to a \]
\end{align*}
%\end{example}

And we somehow know, that \( \texttt{Eq}, \texttt{Num} \subseteq \kindStar \).
Standard Prelude \(\kindStar\)-classes and subkind relation on them is
captured in figure~\ref{diagram:kinds_star1}.
\noindent
\begin{figure}
	\centering
	\scalebox{0.9}{\input{diagram/gen/kinds_star1}}
	\caption[Explicit \uv{star} Prelude classes]{Explicit \(\kindStar\) Prelude classes}
	\label{diagram:kinds_star1}
\end{figure}
One might have doubts about including \(\emptyset\) (with evident semantics) into diagram.
But the notion is natural (class with no instances) and it will become useful in a moment.

There are not uncommon cases where there are more than one \uv{restriction} on type variable.
Consider following example.
% \begin{example}~
\begin{code}
ex :: (C1 a, C2 a) => a
\end{code}
What is meaning of this type? Clearly, \( a \in \texttt{C1} \) and \( a \in \texttt{C2} \) must hold.
Giving familiar notion to this phenomenon we will write following.
\[ \texttt{ex} :: \forall \, a \in \texttt{C1} \cap \texttt{C2} \, . \, a \]
Fragment of emerging structure including standard Prelude classes \texttt{Eq}, \texttt{Ord}, \texttt{Show}, and \texttt{Read}
can be found in figure~\ref{diagram:kinds_star2}.

% \end{example}

\noindent
\begin{figure}
	\centering
	\scalebox{1.0}{\input{diagram/gen/kinds_star2}}
	\caption[Alternative view for some \uv{star} classes]{Alternative view for some \(\kindStar\) classes}
	\label{diagram:kinds_star2}
\end{figure}

We should also notice, that for example class \texttt{Num} forms structure
captured in figure \ref{diagram:num_intersection}. This way it is clear
that not all types with instances for \texttt{Eq} and \texttt{Show}
have to have instance for \texttt{Num}.

Usage of \(\cap\) operator is also one of reasons to include \(\emptyset\)
class.

\noindent
\begin{figure}
	\centering
	\scalebox{1.0}{\input{diagram/gen/num_intersection}}
	\caption[Formation of Num class]{Formation of \texttt{Num} class}
	\label{diagram:num_intersection}
\end{figure}

\noindent
\begin{figure}
	\centering
	\scalebox{1.0}{\input{diagram/gen/kinds_star_star}}
	\caption[Some \uv{emptyset to star} classes]{Some of \(\emptyset \to \kindStar\) classes}
	\label{diagram:kinds_star_star}
\end{figure}

Following example is somehow \uv{problematic}. However, as we will see
later, this is not big deal.

%\begin{example}~
\begin{code}
ex :: (Eq (m a), Monad m) => m a -> a -> Bool
ex x y = x == return y
\end{code}
There are few possibilities how to deal with this. For example
\[ \texttt{ex} :: \forall m \in \texttt{Monad} \cap \emptyset \to \texttt{Eq} \, . \, \forall m \, a \in \texttt{Eq} \, . \, m \, a \to a \to \texttt{Bool} \]
but this would require to make possible quantification not only over variables but over applications too.
% We will rather stick with following alternative:
Alternatively, taking \(\{\_\}\) as a meta-operator mapping type to singleton kind,
it is possible to express desired type by
\[ \texttt{ex} :: \forall a \in \kindStar \, . \, \forall m \in \texttt{Monad} \cap \{ a \} \to \texttt{Eq} \, . \, m \, a \to a \to \texttt{Bool} \]
Both mentioned possibilities embodies some \uv{dependency}, that gives significance to order of quantifications.
We will show how to deal with this later. % XXX : later... multiparam type classes.
%\end{example}

% \begin{example}~
% \begin{code}
% ex :: (Monad m, Eq (m a), Eq a) => m a -> a -> Bool
% ex x y = y == y && x == return y
% \end{code}
% \[ \texttt{ex} :: \forall m \in \texttt{Monad} \cap (\texttt{Eq} \to \texttt{Eq}) \, . \, \forall a \in \texttt{Eq} \, . \, m a \to a \to \texttt{Bool} \]
% \end{example}

This leads to situation, where one th

\section{Mental framework}

In previous section has been pointed out some properties of
Haskell type system that one should take into account when
thinking about it. Following abstract syntax covers what
have been told.

\begin{align*}
	\tau   & ::= \forall \, a \in \kappa \, . \, \tau ~|~ \sigma \\
	\sigma & ::= a ~|~ \sigma \to \sigma ~|~ \rho \, \sigma \\
	\rho   & ::= a ~|~ \rho \, \sigma \\
	\kappa & ::= c ~|~ \kindStar ~|~ \kappa \to \kappa ~|~ \kappa \cap \kappa \\
\end{align*}
where
\begin{itemize}
	\item \(a\) stands for type variable,
	\item \(c\) stands for kind constant,
	\item \(\tau\) represents types,
	\item \(\sigma\) in only technical detail concerning properties of \(\to\),
	\item and \(\kappa\) represents kinds.
\end{itemize}

Key in understanding this fact (noticed by \cite{libor}),
that as classes are sets of type constructors, they are kinds.
Not only that, they form obvious structure~-- intersection-semilattice.

Type class declaration creates new kind constant.
Instances fill selected classes (constants explicitly, others implicitly).
Analogously \texttt{data} creates and fills types.

% XXX: Is it really sort that matters?
Intersection have sense (understand possibility of not-emptiness) only on
kinds with same sort(?) (\(\texttt{Eq} \cap \texttt{Functor}\) even feels wrong).

Inclusion diagrams accompanying some distinguished type classes can be found for
example in \cite{typeclassopedia}.

% XXX: Eventually remove this text and if possible replace
%      with 15 pages of text ;-).
This was expected to generate like 15 pages in thesis \verb~:-/~.

\section{Removing type-class infrastructure}

As noticed by many and underlined by actual implementation, type-classes can be removed
from the language with only little \uv{harm}.

Let us have a look at how it can be done. Take the following well known example.
\begin{code}
class Eq a where
    (==), (/=) :: a -> a -> Bool
\end{code}
And definitions that employ this class.
\begin{code}
(==) :: Eq a => a -> a -> Bool
elem :: Eq a => a -> [a] -> Bool
elem = any . (==)
f :: Eq a => a -> [[a]] -> Bool
f = any . elem
\end{code}
This can be expressed in following way:
\begin{code}
type Eq a = (a -> a -> Bool, a -> a -> Bool)
\end{code}
with definitions
\begin{code}
(==) :: Eq a -> a -> a -> Bool
(==) = fst

elem :: Eq a -> a -> [a] -> Bool
-- elem ((==), (/=)) = any . (==)
-- or
elem i = any . (==) i

f :: Eq a -> a -> [[a]] -> Bool
f i = any . elem i
\end{code}

One may naturally wonder, how it would be with non-\(\kindStar\) classes.
Take \texttt{Monad}.
\begin{code}
class Monad m where
	return :: a -> m a
	(>>=) :: m a -> (a -> m b) -> m b
\end{code}
(Function \texttt{fail} is omitted intentionally but can be added with
no problem.)
Most straightforward way how to express it would be
\begin{code}
type Monad m a b = (a -> m a, m a -> (a -> m b) -> m b)
\end{code}
But what have we done? This is not traditional \texttt{Monad} but
multi-parameter. This is another example for multi-parameter type classes
being natural. But how to do it intended way?
\begin{code}
type Monad m = forall a b . (a -> m a, m a -> (a -> m b) -> m b)
\end{code}


\chapter{Extensions}

This chapters goes trough various type extensions showing examples
what can be achieved using them with focus on what they have in common
and where they differ.

\section{Empty data declarations}

% This extension is implemented in \texttt{GHC} and can be enabled via
% \texttt{LANGUAGE} pragma \texttt{EmptyDataDecls}.
The extension described in this paragraph was included in Haskell 2010 standard.

Extension \emph{empty data declarations} allows empty data declarations
(without any data constructors). This is very natural as there is possible
to declare types with arbitrary number of constructors (except 0). In
fact, it is not extension in sense of adding something artificial in
language, it only make syntax more comprehensive. Using this extension can
be empty (except \(\bot\)) data type \texttt{Empty} declared in this way:
\begin{code}
data Empty
\end{code}
However, the same can be achieved without this extension as well. Consider type \texttt{Empty'}
declared with \texttt{newtype}.
\begin{code}
newtype Empty' = E' Empty'
\end{code}
It looks like there actually are values besides \(\bot\), namely \(\texttt{E'}^n \, \bot\)
for every \(n \in \mathbb{N}_0\) and \(\mu x . \texttt{E'} \, x\).
Those are, as shown in lemma~\ref{emptyTypes}, indistinguishable from \(\bot\).

\begin{lemma}[Empty types]
\label{emptyTypes}
If there is value \(v :: \texttt{Empty'}\), then \(v \approx \bot\).
\end{lemma}

\begin{proof}
In \cite{haskell2010} is stated, that \(\texttt{Empty'} \, \bot \approx \bot\).
Simple induction provides us all \(\texttt{E'}^n \, \bot\) cases
and least fixed point case is obvious as well, as \(\bot\) is least element.
\end{proof}

This \uv{extension} is in fact very natural. Definition of \texttt{Empty'}
might give user feeling that it is non-empty, whereas emptiness is
obvious in case of \texttt{Empty}.

Analogous construction can be done with type constructors.

When defining empty type without this extension be sure to use
\texttt{newtype}, not \texttt{data}, as it will be inhabited not only with \(\bot\).
\begin{code}
data EmptyBad = EB EmptyBad
\end{code}

\begin{lemma}
There exists value \(v :: \texttt{EmptyBad}\) such that \(v \not \approx \bot\).
\end{lemma}

\begin{proof}
Let \texttt{emptyBad} be catamorphism over \texttt{EmptyBad}.
\begin{code}
emptyBad :: (a -> a) -> EmptyBad -> a
emptyBad f (EB x) = f (emptyBad x)
\end{code}
Now consider \(\texttt{emptyBad fac (fix EB)}\) and \(\texttt{emptyBad fac} \, \bot\).
They are obviously distinguishable as first one is factorial function but second one is \(\bot\) itself.
\end{proof}

\section{Multi-parameter type classes}

This extension is implemented in \texttt{GHC} and can be enabled via
\texttt{LANGUAGE} pragma \texttt{MultiParamTypeClasses}.

\subsection{Functional dependencies}

\subsection{Relaxed rules for instances}

\subsubsection{Relaxed rules for the instance head}

\texttt{TypeSynonymInstances} Not much interesting.

\subsubsection{Relaxed rules for instance contexts}

\begin{itemize}
\item \texttt{FlexibleContexts}
\item \texttt{UndecidableInstances}
\item \texttt{OverlappingInstances} \texttt{IncoherentInstances}
\end{itemize}

\section{Generalised algebraic datatypes}

\section{Extensible kinds}

\section{Rank-2 types}

\subsection{Rank-n types}

% \section{Subtyping} % as example

\chapter{Examples}

\section{Apples and oranges}

Problem is simple: we do not want do jumble apples and oranges,
exactly like we were taught in elementary school.

\subsection{Type synonyms}

Simplest way how to \uv{differentiate} fruit under discussion is to define
appropriate type synonyms.
\begin{code}
type Apples  = Integer
type Oranges = Integer
\end{code}
These alternative names can be now used in type signatures to signalise that
particular value represents amount of apples/oranges.

Advantages of this solution include possibility to use all power we have
to manipulate original type (\texttt{Integer} in this case). On the contrary,
safety requirement have not been met, as those type synonyms are equivalent
during type checking. Compiler will have no problem with
code like \texttt{(15 :: Apples) + (27 :: Oranges)}.

\subsection{Type Classes}

Type classes provide another possible solution. We define newtype wrapper
for each fruit type.
\begin{code}
newtype Apples  = Apples  Integer
newtype Oranges = Oranges Integer
\end{code}

Those are fresh new types that only wait for future use.
Addition of two representations of same type of fruit is somehow semantically
always the same, so we want to call it the same name. Overloading of this kind is why
type classes were introduced into the language.
\begin{code}
class Fruit a where
    plus :: a -> a -> a
instance Fruit Apples where
	Apples x `plus` Apples y = Apples (x + y)
instance Fruit Oranges where
	Oranges x `plus` Oranges y = Oranges (x + y)
\end{code}

This way is safety requirement satisfied and function
with same meaning have same names. However, we need to write
very similar definitions for all functions in class
for every new type of fruit over and over. That is clearly
point where unwanted errors can be introduced. So there is still
space for enhancements.


\subsection{Phantom types \& Empty data declarations}

This solution is simple and clean.
\begin{code}
data Apple
data Orange

newtype Count a = Count Integer

plus :: Count a -> Count a -> Count a
Count x `plus` Count y = Count (x + y)
\end{code}
The most interesting thing here is function \texttt{plus}, that itself has a more general type, but
by narrowing it down to more specific one we get a function that allows us
adding up oranges with oranges, apples with apples, but forbids any other combinations
of apples and oranges. Advantage of this solution is that it is polymorphic
and we do not need to separately write code for apples and oranges.

On the contrary, this can be also seen as drawback, as one can create value
of type \texttt{Count Bool} which we have not intended. However,
one can take this in count by writing:
\begin{code}
data Apple
data Orange

class Fruit a where

instance Fruit Apple
instance Fruit Orange

newtype Count a = Count Integer

plus :: Fruit a => Count a -> Count a -> Count a
Count x `plus` Count y = Count (x + y)
\end{code}

% As every elementary school child notices, from time to time one need to add apples and oranges,
% and result will not be such nonsense:
% \begin{code}
% data Fruit'
% instance Fruit Fruit'
%
% plus' :: (Fruit a, Fruit b) => Count a -> Count b -> Count Fruit'
% Count x `plus'` Count y = Count (x + y)
% \end{code}

\section{Subtyping}

\chapter{Unified view}

% \chapter{Own extension proposal}

%\chapter{Z\'aver}
\chapter{Conclusion}

I came to conclusion that violet cows are present mainly in ads.

Oh, and of course:
Someone might think that this work leads to conclusion that Haskell is somehow not good.
That is not true. Big picture. Only good language pushes one to extend it... using features
to its limits, to see what can be done, stimulates thinking about things.

%\bibliographystyle{apalike}
\bibliographystyle{plain}
\bibliography{bibliography}

\end{document}
