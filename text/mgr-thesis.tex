% vim: spell
\documentclass[11pt,oneside,draft]{fithesis2}
%\usepackage[slovak]{babel}
\usepackage[english]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[plainpages=false,pdfpagelabels,unicode]{hyperref}
\usepackage{lmodern}

\usepackage{amsmath,amsthm,amsfonts}
%\usepackage{ae}
\usepackage{fancyvrb}
\usepackage{enumerate}
\clubpenalty=10000
\widowpenalty=10000

\DefineVerbatimEnvironment{code}{Verbatim}
        { fontsize=\small
        , commentchar=@
        , frame=single
        %, numbers=left
        %, framesep=5pt
        %, fontshape=sl
        , commandchars=\\\{\}
        , framesep=5pt
        %, fontshape=sl
        }

\newtheorem{lemma}{Lemma}

%\thesistitle{Rozšírenia typového systému pre Haskell}
\thesistitle{Extensions of Haskell type system}
%\thesissubtitle{Diplomová práca}
%\thesissubtitle{Master Thesis}
\thesissubtitle{Diploma Thesis}
\thesisstudent{Matej Kollár}
\thesiswoman{false}
\thesisfaculty{fi}
%\thesisyear{jar 2011}
\thesisyear{autumn 2011}
\thesisadvisor{Libor Škarvada, RNDr.}
%\thesislang{sk}
\thesislang{en}

\begin{document}
\FrontMatter
\ThesisTitlePage

\begin{ThesisDeclaration}
\DeclarationText
\AdvisorName
\end{ThesisDeclaration}

\begin{ThesisThanks}
I would like to thank to Libor, Zuzana and Mom.
\end{ThesisThanks}

\begin{ThesisAbstract}
The aim of the master's thesis/work is to provide...
\end{ThesisAbstract}

% XXX! Check whether they are relevant.
\begin{ThesisKeyWords}
Haskell, type system, type extension
\end{ThesisKeyWords}

\tableofcontents

\MainMatter

\chapter{Introduction}

\cite{barendregt:1992:lambda, libor}

\chapter{Type system}

(Part of introduction?)\dots

\section{Haskell type system}

\cite{haskell2010}

\chapter{Extensions}

This chapters goes trough various type extensions showing examples
what can be achieved using them with focus on what they have in common
and where they differ.

\section{Empty data declarations}

This extension is implemented in \texttt{GHC} and can be enabled via
\texttt{LANGUAGE} pragma \texttt{EmptyDataDecls}.

Extension \emph{empty data declarations} allows empty data declarations
(without any data constructors). This is very natural as there is possible
to declare types with arbitrary number of constructors (except 0). In
fact, it is not extension in sense of adding something artificial in
language, it only make syntax more comprehensive. Using this extension can
be empty (except \(\bot\)) data type \texttt{Empty} declared in this way:
\begin{code}
data Empty
\end{code}
However, the same can be achieved without this extension as well. Consider type \texttt{Empty'}
declared with \texttt{newtype}.
\begin{code}
newtype Empty' = E' Empty'
\end{code}
It looks like there actually are values besides \(\bot\), namely \(\texttt{E'}^n \, \bot\)
for every \(n \in \mathbb{N}_0\) and \(\mu x . \texttt{E'} \, x\).
Those are, as shown in lemma \ref{emptyTypes}, indistinguishable from \(\bot\).

\begin{lemma}[Empty types]
\label{emptyTypes}
If there is value \(v :: \texttt{Empty'}\), then \(v \approx \bot\).
\end{lemma}

\begin{proof}
In \cite{haskell2010} is stated, that \(\texttt{Empty'} \, \bot \approx \bot\).
Simple induction provides us all \(\texttt{E'}^n \, \bot\) cases
and least fixed point case is obvious as well, as \(\bot\) is least element.
\end{proof}

This ``extension'' is in fact very natural. Definition of \texttt{Empty'}
might give user feeling that it is non-empty, whereas emptiness is
obvious in case of \texttt{Empty}.

Analogous construction can be done with type constructors.

When defining empty type without this extension be sure to use
\texttt{newtype}, not \texttt{data}, as it will be inhabited not only with \(\bot\).
\begin{code}
data EmptyBad = EB EmptyBad
\end{code}

\begin{lemma}
There exists value \(v :: \texttt{EmptyBad}\) such that \(v \not \approx \bot\).
\end{lemma}

\begin{proof}
Let \texttt{emptyBad} be catamorphism over \texttt{EmptyBad}.
\begin{code}
emptyBad :: (a -> a) -> EmptyBad -> a
emptyBad f (EB x) = f (emptyBad x)
\end{code}
Now consider \(\texttt{emptyBad fac (fix EB)}\) and \(\texttt{emptyBad fac} \, \bot\).
They are obviously distinguishable as first one is factorial function but second one is \(\bot\) itself.
\end{proof}

\subsection{Examples}

Apples and oranges\dots

% \section{Phantom types}

\section{Multi-parameter type classes}

This extension is implemented in \texttt{GHC} and can be enabled via
\texttt{LANGUAGE} pragma \texttt{MultiParamTypeClasses}.

\subsection{Functional dependencies}

\subsection{Relaxed rules for instances}

\subsubsection{Relaxed rules for the instance head}

\texttt{TypeSynonymInstances} Not much interesting.

\subsubsection{Relaxed rules for instance contexts}

\begin{itemize}
\item \texttt{FlexibleContexts}
\item \texttt{UndecidableInstances}
\item \texttt{OverlappingInstances} \texttt{IncoherentInstances}
\end{itemize}

\subsection{Examples}

Subtyping.

\section{Generalised algebraic datatypes}

\section{Extensible kinds}

\section{Rank-2 types}

\subsection{Rank-n types}

% \section{Subtyping} % as example

\chapter{Unified view}

% \chapter{Own extension proposal}

%\chapter{Z\'aver}
\chapter{Conclusion}

I came to conclusion that violet cows are present mainly in ads.

\bibliographystyle{apalike}
\bibliography{bibliography}

\end{document}
